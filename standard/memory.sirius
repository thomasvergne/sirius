use io;

extern realloc[a](ptr: ref a, size: Int): ref a;
extern malloc[a](size: Int): ref a;
extern free[a](ptr: ref a): Void;
extern void: Void

struct Reference[a] {
  value: ref a,
  ref_count: ref Int
}

property (c: a) free[a](): Void;

// Memory management related
with no-reference-counting fn new_reference[a](value: ref a): Reference[a] = {
  let ref r: Reference[a] = malloc(sizeof ref Reference[a]);
  r->value = value;
  *r->ref_count = 1; 

  *r
}

with no-reference-counting
fn deref[a](r: Reference[a]): ref a = r.value;

with no-reference-counting
fn free_reference[a](r: Reference[a]): Int = {
  *r.ref_count = *r.ref_count - 1;
  if *r.ref_count == 0 {
    r.value.free();
    r.ref_count.free();
  }
  0
}

with no-reference-counting
fn copy_reference[a](r: Reference[a]): Reference[a] = {
  *r.ref_count = *r.ref_count + 1;
  r
}

with no-reference-counting
fn ref_malloc[a](size: Int): Reference[a] = {
  let ref r: Reference[a] = malloc(sizeof ref Reference[a]);
  let ref count: Int = malloc(sizeof ref Int);
  r->ref_count = count;
  r->value = malloc(size);
  *r->ref_count = 1;

  *r
}

with no-reference-counting
fn ref_realloc[a](ptr: Reference[Int], size: Int): Reference[a] = {
  let ref r: Reference[a] = malloc(sizeof ref Reference[a]);
  r->value = realloc(ptr.value, size);
  *r->ref_count = *ptr.ref_count + 1;

  *r
}

fn (c: ref a) free[a](): Void = {
  c->free();
  free(c);
} 

fn (c: Int) free(): Void = void;
fn (c: Reference[a]) show[a](): String = (*c.value).show();